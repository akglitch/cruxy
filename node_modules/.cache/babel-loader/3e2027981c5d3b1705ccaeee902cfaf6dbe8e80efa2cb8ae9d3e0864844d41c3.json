{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */let $488c6ddbf4ef74c2$var$formatterCache = new Map();\nlet $488c6ddbf4ef74c2$var$supportsSignDisplay = false;\ntry {\n  // @ts-ignore\n  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat('de-DE', {\n    signDisplay: 'exceptZero'\n  }).resolvedOptions().signDisplay === 'exceptZero';\n  // eslint-disable-next-line no-empty\n} catch (e) {}\nlet $488c6ddbf4ef74c2$var$supportsUnit = false;\ntry {\n  // @ts-ignore\n  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat('de-DE', {\n    style: 'unit',\n    unit: 'degree'\n  }).resolvedOptions().style === 'unit';\n  // eslint-disable-next-line no-empty\n} catch (e1) {}\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\n// Values were determined by switching to each locale manually in Chrome.\nconst $488c6ddbf4ef74c2$var$UNITS = {\n  degree: {\n    narrow: {\n      default: '°',\n      'ja-JP': ' 度',\n      'zh-TW': '度',\n      'sl-SI': ' °'\n    }\n  }\n};\nclass $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {\n  /** Formats a number value as a string, according to the locale and options provided to the constructor. */format(value) {\n    let res = '';\n    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);else res = this.numberFormatter.format(value);\n    if (this.options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {\n      var ref;\n      let {\n        unit: unit,\n        unitDisplay = 'short',\n        locale: locale\n      } = this.resolvedOptions();\n      let values = (ref = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || ref === void 0 ? void 0 : ref[unitDisplay];\n      res += values[locale] || values.default;\n    }\n    return res;\n  }\n  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */\n  formatToParts(value) {\n    // TODO: implement signDisplay for formatToParts\n    // @ts-ignore\n    return this.numberFormatter.formatToParts(value);\n  }\n  /** Formats a number range as a string. */\n  formatRange(start, end) {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRange === 'function')\n      // @ts-ignore\n      return this.numberFormatter.formatRange(start, end);\n    if (end < start) throw new RangeError('End date must be >= start date');\n    // Very basic fallback for old browsers.\n    return `${this.format(start)} – ${this.format(end)}`;\n  }\n  /** Formats a number range as an array of parts. */\n  formatRangeToParts(start, end) {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRangeToParts === 'function')\n      // @ts-ignore\n      return this.numberFormatter.formatRangeToParts(start, end);\n    if (end < start) throw new RangeError('End date must be >= start date');\n    let startParts = this.numberFormatter.formatToParts(start);\n    let endParts = this.numberFormatter.formatToParts(end);\n    return [...startParts.map(p => ({\n      ...p,\n      source: 'startRange'\n    })), {\n      type: 'literal',\n      value: ' – ',\n      source: 'shared'\n    }, ...endParts.map(p => ({\n      ...p,\n      source: 'endRange'\n    }))];\n  }\n  /** Returns the resolved formatting options based on the values passed to the constructor. */\n  resolvedOptions() {\n    let options = this.numberFormatter.resolvedOptions();\n    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {\n      ...options,\n      signDisplay: this.options.signDisplay\n    };\n    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === 'unit') options = {\n      ...options,\n      style: 'unit',\n      unit: this.options.unit,\n      unitDisplay: this.options.unitDisplay\n    };\n    return options;\n  }\n  constructor(locale) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);\n    this.options = options;\n  }\n}\nfunction $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    numberingSystem: numberingSystem\n  } = options;\n  if (numberingSystem && locale.indexOf('-u-nu-') === -1) locale = `${locale}-u-nu-${numberingSystem}`;\n  if (options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {\n    var ref;\n    let {\n      unit: unit,\n      unitDisplay = 'short'\n    } = options;\n    if (!unit) throw new Error('unit option must be provided with style: \"unit\"');\n    if (!((ref = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || ref === void 0 ? void 0 : ref[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\n    options = {\n      ...options,\n      style: 'decimal'\n    };\n  }\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);\n  let numberFormatter = new Intl.NumberFormat(locale, options);\n  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);\n  return numberFormatter;\n}\nfunction $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {\n  if (signDisplay === 'auto') return numberFormat.format(num);else if (signDisplay === 'never') return numberFormat.format(Math.abs(num));else {\n    let needsPositiveSign = false;\n    if (signDisplay === 'always') needsPositiveSign = num > 0 || Object.is(num, 0);else if (signDisplay === 'exceptZero') {\n      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);else needsPositiveSign = num > 0;\n    }\n    if (needsPositiveSign) {\n      let negative = numberFormat.format(-num);\n      let noSign = numberFormat.format(num);\n      // ignore RTL/LTR marker character\n      let minus = negative.replace(noSign, '').replace(/\\u200e|\\u061C/, '');\n      if ([...minus].length !== 1) console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');\n      let positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);\n      return positive;\n    } else return numberFormat.format(num);\n  }\n}\nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp('^.*\\\\(.*\\\\).*$');\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = ['latn', 'arab', 'hanidec'];\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\n  /**\n  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n  */\n  parse(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\n  }\n  /**\n  * Returns whether the given string could potentially be a valid number. This should be used to\n  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n  * of the minus/plus sign characters can be checked.\n  */\n  isValidPartialNumber(value, minValue, maxValue) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n  }\n  /**\n  * Returns a numbering system for which the given string is valid in the current locale.\n  * If no numbering system could be detected, the default numbering system for the current\n  * locale is returned.\n  */\n  getNumberingSystem(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n  }\n  constructor(locale) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.locale = locale;\n    this.options = options;\n  }\n}\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\n  // First try the default numbering system for the provided locale\n  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\n  // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n  // try each of the other supported numbering systems until we find one that matches.\n  if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {\n    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {\n      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);\n      if (parser.isValidPartialNumber(value)) return parser;\n    }\n  }\n  return defaultParser;\n}\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\n  if (!parser) {\n    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\n    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\n  }\n  return parser;\n}\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass $6c7bd7858deea686$var$NumberParserImpl {\n  parse(value) {\n    // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n    let fullySanitizedValue = this.sanitize(value);\n    // Remove group characters, and replace decimal points and numerals with ASCII values.\n    fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, '').replace(this.symbols.decimal, '.').replace(this.symbols.minusSign, '-').replace(this.symbols.numeral, this.symbols.index);\n    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n    if (isNaN(newValue)) return NaN;\n    // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n    if (this.options.currencySign === 'accounting' && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\n    // when reading the number, if it's a percent, then it should be interpreted as being divided by 100\n    if (this.options.style === 'percent') {\n      newValue /= 100;\n      var _maximumFractionDigits;\n      // after dividing to get the percent value, javascript may get .0210999999 instead of .0211, so fix the number of fraction digits\n      newValue = +newValue.toFixed(((_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _maximumFractionDigits !== void 0 ? _maximumFractionDigits : 0) + 2);\n    }\n    return newValue;\n  }\n  sanitize(value) {\n    // Remove literals and whitespace, which are allowed anywhere in the string\n    value = value.replace(this.symbols.literals, '');\n    // Replace the ASCII minus sign with the minus sign used in the current locale\n    // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n    value = value.replace('-', this.symbols.minusSign);\n    // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n    // instead they use the , (44) character or apparently the (1548) character.\n    if (this.options.numberingSystem === 'arab') {\n      value = value.replace(',', this.symbols.decimal);\n      value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n      value = $6c7bd7858deea686$var$replaceAll(value, '.', this.symbols.group);\n    }\n    // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n    // so allow 'period' as a group char and replace it with a space\n    if (this.options.locale === 'fr-FR') value = $6c7bd7858deea686$var$replaceAll(value, '.', String.fromCharCode(8239));\n    return value;\n  }\n  isValidPartialNumber(value) {\n    let minValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n    let maxValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n    value = this.sanitize(value);\n    // Remove minus or plus sign, which must be at the start of the string.\n    if (value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\n    // Numbers cannot start with a group separator\n    if (value.startsWith(this.symbols.group)) return false;\n    // Remove numerals, groups, and decimals\n    value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, '').replace(this.symbols.numeral, '').replace(this.symbols.decimal, '');\n    // The number is valid if there are no remaining characters\n    return value.length === 0;\n  }\n  constructor(locale) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.formatter = new Intl.NumberFormat(locale, options);\n    this.options = this.formatter.resolvedOptions();\n    this.symbols = $6c7bd7858deea686$var$getSymbols(this.formatter, this.options, options);\n  }\n}\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set(['decimal', 'fraction', 'integer', 'minusSign', 'plusSign', 'group']);\nfunction $6c7bd7858deea686$var$getSymbols(formatter, intlOptions, originalOptions) {\n  var ref, ref1, ref2, ref3;\n  // Note: some locale's don't add a group symbol until there is a ten thousands place\n  let allParts = formatter.formatToParts(-10000.111);\n  let posAllParts = formatter.formatToParts(10000.111);\n  let singularParts = formatter.formatToParts(1);\n  var ref4;\n  let minusSign = (ref4 = (ref = allParts.find(p => p.type === 'minusSign')) === null || ref === void 0 ? void 0 : ref.value) !== null && ref4 !== void 0 ? ref4 : '-';\n  let plusSign = (ref1 = posAllParts.find(p => p.type === 'plusSign')) === null || ref1 === void 0 ? void 0 : ref1.value;\n  // Safari does not support the signDisplay option, but our number parser polyfills it.\n  // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n  // @ts-ignore\n  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'exceptZero' || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'always')) plusSign = '+';\n  let decimal = (ref2 = allParts.find(p => p.type === 'decimal')) === null || ref2 === void 0 ? void 0 : ref2.value;\n  let group = (ref3 = allParts.find(p => p.type === 'group')) === null || ref3 === void 0 ? void 0 : ref3.value;\n  // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n  // don't contribute to the numerical value\n  let pluralLiterals = allParts.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value));\n  let singularLiterals = singularParts.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value));\n  let sortedLiterals = [...new Set([...singularLiterals, ...pluralLiterals])].sort((a, b) => b.length - a.length);\n  let literals = sortedLiterals.length === 0 ? new RegExp('[\\\\p{White_Space}]', 'gu') : new RegExp(`${sortedLiterals.join('|')}|[\\\\p{White_Space}]`, 'gu');\n  // These are for replacing non-latn characters with the latn equivalent\n  let numerals = [...new Intl.NumberFormat(intlOptions.locale, {\n    useGrouping: false\n  }).format(9876543210)].reverse();\n  let indexes = new Map(numerals.map((d, i) => [d, i]));\n  let numeral = new RegExp(`[${numerals.join('')}]`, 'g');\n  let index = d => String(indexes.get(d));\n  return {\n    minusSign: minusSign,\n    plusSign: plusSign,\n    decimal: decimal,\n    group: group,\n    literals: literals,\n    numeral: numeral,\n    index: index\n  };\n}\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\n  // @ts-ignore\n  if (str.replaceAll)\n    // @ts-ignore\n    return str.replaceAll(find, replace);\n  return str.split(find).join(replace);\n}\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nexport { $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 as NumberFormatter, $6c7bd7858deea686$export$cd11ab140839f11d as NumberParser };","map":{"version":3,"mappings":"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","names":["$488c6ddbf4ef74c2$var$formatterCache","Map","$488c6ddbf4ef74c2$var$supportsSignDisplay","Intl","NumberFormat","signDisplay","resolvedOptions","e","$488c6ddbf4ef74c2$var$supportsUnit","style","unit","e1","$488c6ddbf4ef74c2$var$UNITS","degree","narrow","default","$488c6ddbf4ef74c2$export$cc77c4ff7e8673c5","format","value","res","options","$488c6ddbf4ef74c2$export$711b50b3c525e0f2","numberFormatter","ref","unitDisplay","locale","values","formatToParts","formatRange","start","end","RangeError","formatRangeToParts","startParts","endParts","map","p","source","type","$488c6ddbf4ef74c2$var$getCachedNumberFormatter","numberingSystem","indexOf","Error","cacheKey","Object","entries","sort","a","b","join","has","get","set","numberFormat","num","Math","abs","needsPositiveSign","is","negative","noSign","minus","replace","length","console","warn","positive","$6c7bd7858deea686$var$CURRENCY_SIGN_REGEX","RegExp","$6c7bd7858deea686$var$NUMBERING_SYSTEMS","$6c7bd7858deea686$export$cd11ab140839f11d","parse","$6c7bd7858deea686$var$getNumberParserImpl","isValidPartialNumber","minValue","maxValue","getNumberingSystem","$6c7bd7858deea686$var$numberParserCache","defaultParser","$6c7bd7858deea686$var$getCachedNumberParser","includes","parser","$6c7bd7858deea686$var$NumberParserImpl","fullySanitizedValue","sanitize","$6c7bd7858deea686$var$replaceAll","symbols","group","decimal","minusSign","numeral","index","newValue","NaN","isNaN","currencySign","test","_maximumFractionDigits","toFixed","maximumFractionDigits","literals","String","fromCharCode","Infinity","startsWith","slice","plusSign","formatter","$6c7bd7858deea686$var$getSymbols","$6c7bd7858deea686$var$nonLiteralParts","Set","intlOptions","originalOptions","ref1","ref2","ref3","allParts","posAllParts","singularParts","ref4","find","pluralLiterals","filter","$6c7bd7858deea686$var$escapeRegex","singularLiterals","sortedLiterals","numerals","useGrouping","reverse","indexes","d","i","str","replaceAll","split","string"],"sources":["/home/kaytee/Desktop/cruxy/node_modules/@internationalized/number/dist/packages/@internationalized/number/src/NumberFormatter.ts","/home/kaytee/Desktop/cruxy/node_modules/@internationalized/number/dist/packages/@internationalized/number/src/NumberParser.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nlet formatterCache = new Map<string, Intl.NumberFormat>();\n\nlet supportsSignDisplay = false;\ntry {\n  // @ts-ignore\n  supportsSignDisplay = (new Intl.NumberFormat('de-DE', {signDisplay: 'exceptZero'})).resolvedOptions().signDisplay === 'exceptZero';\n  // eslint-disable-next-line no-empty\n} catch (e) {}\n\nlet supportsUnit = false;\ntry {\n  // @ts-ignore\n  supportsUnit = (new Intl.NumberFormat('de-DE', {style: 'unit', unit: 'degree'})).resolvedOptions().style === 'unit';\n  // eslint-disable-next-line no-empty\n} catch (e) {}\n\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\n// Values were determined by switching to each locale manually in Chrome.\nconst UNITS = {\n  degree: {\n    narrow: {\n      default: '°',\n      'ja-JP': ' 度',\n      'zh-TW': '度',\n      'sl-SI': ' °'\n      // Arabic?? But Safari already doesn't use Arabic digits so might be ok...\n      // https://bugs.webkit.org/show_bug.cgi?id=218139\n    }\n  }\n};\n\nexport interface NumberFormatOptions extends Intl.NumberFormatOptions {\n  /** Overrides default numbering system for the current locale. */\n  numberingSystem?: string\n}\n\ninterface NumberRangeFormatPart extends Intl.NumberFormatPart {\n  source: 'startRange' | 'endRange' | 'shared'\n}\n\n/**\n * A wrapper around Intl.NumberFormat providing additional options, polyfills, and caching for performance.\n */\nexport class NumberFormatter implements Intl.NumberFormat {\n  private numberFormatter: Intl.NumberFormat;\n  private options: NumberFormatOptions;\n\n  constructor(locale: string, options: NumberFormatOptions = {}) {\n    this.numberFormatter = getCachedNumberFormatter(locale, options);\n    this.options = options;\n  }\n\n  /** Formats a number value as a string, according to the locale and options provided to the constructor. */\n  format(value: number): string {\n    let res = '';\n    if (!supportsSignDisplay && this.options.signDisplay != null) {\n      res = numberFormatSignDisplayPolyfill(this.numberFormatter, this.options.signDisplay, value);\n    } else {\n      res = this.numberFormatter.format(value);\n    }\n\n    if (this.options.style === 'unit' && !supportsUnit) {\n      let {unit, unitDisplay = 'short', locale} = this.resolvedOptions();\n      let values = UNITS[unit]?.[unitDisplay];\n      res += values[locale] || values.default;\n    }\n\n    return res;\n  }\n\n  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */\n  formatToParts(value: number): Intl.NumberFormatPart[] {\n    // TODO: implement signDisplay for formatToParts\n    // @ts-ignore\n    return this.numberFormatter.formatToParts(value);\n  }\n\n  /** Formats a number range as a string. */\n  formatRange(start: number, end: number): string {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRange === 'function') {\n      // @ts-ignore\n      return this.numberFormatter.formatRange(start, end);\n    }\n\n    if (end < start) {\n      throw new RangeError('End date must be >= start date');\n    }\n\n    // Very basic fallback for old browsers.\n    return `${this.format(start)} – ${this.format(end)}`;\n  }\n\n  /** Formats a number range as an array of parts. */\n  formatRangeToParts(start: number, end: number): NumberRangeFormatPart[] {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRangeToParts === 'function') {\n      // @ts-ignore\n      return this.numberFormatter.formatRangeToParts(start, end);\n    }\n\n    if (end < start) {\n      throw new RangeError('End date must be >= start date');\n    }\n\n    let startParts = this.numberFormatter.formatToParts(start);\n    let endParts = this.numberFormatter.formatToParts(end);\n    return [\n      ...startParts.map(p => ({...p, source: 'startRange'} as NumberRangeFormatPart)),\n      {type: 'literal', value: ' – ', source: 'shared'},\n      ...endParts.map(p => ({...p, source: 'endRange'} as NumberRangeFormatPart))\n    ];\n  }\n\n  /** Returns the resolved formatting options based on the values passed to the constructor. */\n  resolvedOptions(): Intl.ResolvedNumberFormatOptions {\n    let options = this.numberFormatter.resolvedOptions();\n    if (!supportsSignDisplay && this.options.signDisplay != null) {\n      options = {...options, signDisplay: this.options.signDisplay};\n    }\n\n    if (!supportsUnit && this.options.style === 'unit') {\n      options = {...options, style: 'unit', unit: this.options.unit, unitDisplay: this.options.unitDisplay};\n    }\n\n    return options;\n  }\n}\n\nfunction getCachedNumberFormatter(locale: string, options: NumberFormatOptions = {}): Intl.NumberFormat {\n  let {numberingSystem} = options;\n  if (numberingSystem && locale.indexOf('-u-nu-') === -1) {\n    locale = `${locale}-u-nu-${numberingSystem}`;\n  }\n\n  if (options.style === 'unit' && !supportsUnit) {\n    let {unit, unitDisplay = 'short'} = options;\n    if (!unit) {\n      throw new Error('unit option must be provided with style: \"unit\"');\n    }\n    if (!UNITS[unit]?.[unitDisplay]) {\n      throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\n    }\n    options = {...options, style: 'decimal'};\n  }\n\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  if (formatterCache.has(cacheKey)) {\n    return formatterCache.get(cacheKey);\n  }\n\n  let numberFormatter = new Intl.NumberFormat(locale, options);\n  formatterCache.set(cacheKey, numberFormatter);\n  return numberFormatter;\n}\n\n/** @private - exported for tests */\nexport function numberFormatSignDisplayPolyfill(numberFormat: Intl.NumberFormat, signDisplay: string, num: number) {\n  if (signDisplay === 'auto') {\n    return numberFormat.format(num);\n  } else if (signDisplay === 'never') {\n    return numberFormat.format(Math.abs(num));\n  } else {\n    let needsPositiveSign = false;\n    if (signDisplay === 'always') {\n      needsPositiveSign = num > 0 || Object.is(num, 0);\n    } else if (signDisplay === 'exceptZero') {\n      if (Object.is(num, -0) || Object.is(num, 0)) {\n        num = Math.abs(num);\n      } else {\n        needsPositiveSign = num > 0;\n      }\n    }\n\n    if (needsPositiveSign) {\n      let negative = numberFormat.format(-num);\n      let noSign = numberFormat.format(num);\n      // ignore RTL/LTR marker character\n      let minus = negative.replace(noSign, '').replace(/\\u200e|\\u061C/, '');\n      if ([...minus].length !== 1) {\n        console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');\n      }\n      let positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);\n      return positive;\n    } else {\n      return numberFormat.format(num);\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\ninterface Symbols {\n  minusSign: string,\n  plusSign: string,\n  decimal: string,\n  group: string,\n  literals: RegExp,\n  numeral: RegExp,\n  index: (v: string) => string\n}\n\nconst CURRENCY_SIGN_REGEX = new RegExp('^.*\\\\(.*\\\\).*$');\nconst NUMBERING_SYSTEMS = ['latn', 'arab', 'hanidec'];\n\n/**\n * A NumberParser can be used to perform locale-aware parsing of numbers from Unicode strings,\n * as well as validation of partial user input. It automatically detects the numbering system\n * used in the input, and supports parsing decimals, percentages, currency values, and units\n * according to the locale.\n */\nexport class NumberParser {\n  private locale: string;\n  private options: Intl.NumberFormatOptions;\n\n  constructor(locale: string, options: Intl.NumberFormatOptions = {}) {\n    this.locale = locale;\n    this.options = options;\n  }\n\n  /**\n   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n   */\n  parse(value: string): number {\n    return getNumberParserImpl(this.locale, this.options, value).parse(value);\n  }\n\n  /**\n   * Returns whether the given string could potentially be a valid number. This should be used to\n   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n   * of the minus/plus sign characters can be checked.\n   */\n  isValidPartialNumber(value: string, minValue?: number, maxValue?: number): boolean {\n    return getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n  }\n\n  /**\n   * Returns a numbering system for which the given string is valid in the current locale.\n   * If no numbering system could be detected, the default numbering system for the current\n   * locale is returned.\n   */\n  getNumberingSystem(value: string): string {\n    return getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n  }\n}\n\nconst numberParserCache = new Map<string, NumberParserImpl>();\nfunction getNumberParserImpl(locale: string, options: Intl.NumberFormatOptions, value: string) {\n  // First try the default numbering system for the provided locale\n  let defaultParser = getCachedNumberParser(locale, options);\n\n  // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n  // try each of the other supported numbering systems until we find one that matches.\n  if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {\n    for (let numberingSystem of NUMBERING_SYSTEMS) {\n      if (numberingSystem !== defaultParser.options.numberingSystem) {\n        let parser = getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);\n        if (parser.isValidPartialNumber(value)) {\n          return parser;\n        }\n      }\n    }\n  }\n\n  return defaultParser;\n}\n\nfunction getCachedNumberParser(locale: string, options: Intl.NumberFormatOptions) {\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  let parser = numberParserCache.get(cacheKey);\n  if (!parser) {\n    parser = new NumberParserImpl(locale, options);\n    numberParserCache.set(cacheKey, parser);\n  }\n\n  return parser;\n}\n\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass NumberParserImpl {\n  formatter: Intl.NumberFormat;\n  options: Intl.ResolvedNumberFormatOptions;\n  symbols: Symbols;\n\n  constructor(locale: string, options: Intl.NumberFormatOptions = {}) {\n    this.formatter = new Intl.NumberFormat(locale, options);\n    this.options = this.formatter.resolvedOptions();\n    this.symbols = getSymbols(this.formatter, this.options, options);\n  }\n\n  parse(value: string) {\n    // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n    let fullySanitizedValue = this.sanitize(value);\n\n    // Remove group characters, and replace decimal points and numerals with ASCII values.\n    fullySanitizedValue = replaceAll(fullySanitizedValue, this.symbols.group, '')\n      .replace(this.symbols.decimal, '.')\n      .replace(this.symbols.minusSign, '-')\n      .replace(this.symbols.numeral, this.symbols.index);\n\n    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n    if (isNaN(newValue)) {\n      return NaN;\n    }\n\n    // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n    if (this.options.currencySign === 'accounting' && CURRENCY_SIGN_REGEX.test(value)) {\n      newValue = -1 * newValue;\n    }\n\n    // when reading the number, if it's a percent, then it should be interpreted as being divided by 100\n    if (this.options.style === 'percent') {\n      newValue /= 100;\n      // after dividing to get the percent value, javascript may get .0210999999 instead of .0211, so fix the number of fraction digits\n      newValue = +newValue.toFixed((this.options.maximumFractionDigits ?? 0) + 2);\n    }\n\n    return newValue;\n  }\n\n  sanitize(value: string) {\n    // Remove literals and whitespace, which are allowed anywhere in the string\n    value = value.replace(this.symbols.literals, '');\n\n    // Replace the ASCII minus sign with the minus sign used in the current locale\n    // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n    value = value.replace('-', this.symbols.minusSign);\n\n    // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n    // instead they use the , (44) character or apparently the (1548) character.\n    if (this.options.numberingSystem === 'arab') {\n      value = value.replace(',', this.symbols.decimal);\n      value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n      value = replaceAll(value, '.', this.symbols.group);\n    }\n\n    // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n    // so allow 'period' as a group char and replace it with a space\n    if (this.options.locale === 'fr-FR') {\n      value = replaceAll(value, '.', String.fromCharCode(8239));\n    }\n\n    return value;\n  }\n\n  isValidPartialNumber(value: string, minValue: number = -Infinity, maxValue: number = Infinity): boolean {\n    value = this.sanitize(value);\n\n    // Remove minus or plus sign, which must be at the start of the string.\n    if (value.startsWith(this.symbols.minusSign) && minValue < 0) {\n      value = value.slice(this.symbols.minusSign.length);\n    } else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) {\n      value = value.slice(this.symbols.plusSign.length);\n    }\n\n    // Numbers cannot start with a group separator\n    if (value.startsWith(this.symbols.group)) {\n      return false;\n    }\n\n    // Remove numerals, groups, and decimals\n    value = replaceAll(value, this.symbols.group, '')\n      .replace(this.symbols.numeral, '')\n      .replace(this.symbols.decimal, '');\n\n    // The number is valid if there are no remaining characters\n    return value.length === 0;\n  }\n}\n\nconst nonLiteralParts = new Set(['decimal', 'fraction', 'integer', 'minusSign', 'plusSign', 'group']);\n\nfunction getSymbols(formatter: Intl.NumberFormat, intlOptions: Intl.ResolvedNumberFormatOptions, originalOptions: Intl.NumberFormatOptions): Symbols {\n  // Note: some locale's don't add a group symbol until there is a ten thousands place\n  let allParts = formatter.formatToParts(-10000.111);\n  let posAllParts = formatter.formatToParts(10000.111);\n  let singularParts = formatter.formatToParts(1);\n\n  let minusSign = allParts.find(p => p.type === 'minusSign')?.value ?? '-';\n  let plusSign = posAllParts.find(p => p.type === 'plusSign')?.value;\n\n  // Safari does not support the signDisplay option, but our number parser polyfills it.\n  // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n  // @ts-ignore\n  if (!plusSign && (originalOptions?.signDisplay === 'exceptZero' || originalOptions?.signDisplay === 'always')) {\n    plusSign = '+';\n  }\n\n  let decimal = allParts.find(p => p.type === 'decimal')?.value;\n  let group = allParts.find(p => p.type === 'group')?.value;\n\n  // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n  // don't contribute to the numerical value\n  let pluralLiterals = allParts.filter(p => !nonLiteralParts.has(p.type)).map(p => escapeRegex(p.value));\n  let singularLiterals = singularParts.filter(p => !nonLiteralParts.has(p.type)).map(p => escapeRegex(p.value));\n  let sortedLiterals = [...new Set([...singularLiterals, ...pluralLiterals])].sort((a, b) => b.length - a.length);\n  let literals = sortedLiterals.length === 0 ? \n      new RegExp('[\\\\p{White_Space}]', 'gu') :\n      new RegExp(`${sortedLiterals.join('|')}|[\\\\p{White_Space}]`, 'gu');\n\n  // These are for replacing non-latn characters with the latn equivalent\n  let numerals = [...new Intl.NumberFormat(intlOptions.locale, {useGrouping: false}).format(9876543210)].reverse();\n  let indexes = new Map(numerals.map((d, i) => [d, i]));\n  let numeral = new RegExp(`[${numerals.join('')}]`, 'g');\n  let index = d => String(indexes.get(d));\n\n  return {minusSign, plusSign, decimal, group, literals, numeral, index};\n}\n\nfunction replaceAll(str: string, find: string, replace: string) {\n  // @ts-ignore\n  if (str.replaceAll) {\n    // @ts-ignore\n    return str.replaceAll(find, replace);\n  }\n\n  return str.split(find).join(replace);\n}\n\nfunction escapeRegex(string: string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}