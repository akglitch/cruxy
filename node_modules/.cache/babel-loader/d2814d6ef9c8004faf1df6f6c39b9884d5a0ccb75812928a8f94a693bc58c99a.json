{"ast":null,"code":"import { useMemo as $cAn5f$useMemo, useEffect as $cAn5f$useEffect } from \"react\";\nimport { useMultipleSelectionState as $cAn5f$useMultipleSelectionState, SelectionManager as $cAn5f$SelectionManager } from \"@react-stately/selection\";\nfunction $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n  let {\n    collection: collection,\n    focusMode: focusMode\n  } = props;\n  let selectionState = $cAn5f$useMultipleSelectionState(props);\n  let disabledKeys = $cAn5f$useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if ((item === null || item === void 0 ? void 0 : item.type) === 'item') {\n        var ref, ref1;\n        let children = [...item.childNodes];\n        if (child === 'last') key = (ref = children[children.length - 1]) === null || ref === void 0 ? void 0 : ref.key;else key = (ref1 = children[0]) === null || ref1 === void 0 ? void 0 : ref1.key;\n      }\n    }\n    setFocusedKey(key, child);\n  };\n  // Reset focused key if that item is deleted from the collection.\n  $cAn5f$useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n  }, [collection, selectionState]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: new $cAn5f$SelectionManager(collection, selectionState)\n  };\n}\nvar tmp = Symbol.iterator;\nclass $16805b1b18093c5f$export$de3fdf6493c353d {\n  *[tmp]() {\n    yield* [...this.rows];\n  }\n  get size() {\n    return [...this.rows].length;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    var ref;\n    return (ref = [...this.rows][0]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n  getLastKey() {\n    var ref;\n    let rows = [...this.rows];\n    return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  constructor(opts) {\n    this.keyMap = new Map();\n    this.keyMap = new Map();\n    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n    this.rows = [];\n    let visit = node => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) node = opts.visitNode(node);\n      this.keyMap.set(node.key, node);\n      let childKeys = new Set();\n      let last;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null)\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        childKeys.add(child.key);\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else child.prevKey = null;\n        visit(child);\n        last = child;\n      }\n      if (last) last.nextKey = null;\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) if (!childKeys.has(child.key)) remove(child);\n      }\n    };\n    let remove = node => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) if (this.keyMap.get(child.key) === child) remove(child);\n    };\n    let last1;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      };\n      if (last1) {\n        last1.nextKey = rowNode.key;\n        rowNode.prevKey = last1.key;\n      } else rowNode.prevKey = null;\n      this.rows.push(rowNode);\n      visit(rowNode);\n      last1 = rowNode;\n    });\n    if (last1) last1.nextKey = null;\n  }\n}\nexport { $62967d126f3aa823$export$4007ac09ff9c68ed as useGridState, $16805b1b18093c5f$export$de3fdf6493c353d as GridCollection };","map":{"version":3,"mappings":"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","names":["$62967d126f3aa823$export$4007ac09ff9c68ed","props","collection","focusMode","selectionState","$cAn5f$useMultipleSelectionState","disabledKeys","$cAn5f$useMemo","Set","setFocusedKey","key","child","item","getItem","type","ref","ref1","children","childNodes","length","$cAn5f$useEffect","focusedKey","isKeyboardNavigationDisabled","selectionManager","$cAn5f$SelectionManager","Symbol","iterator","$16805b1b18093c5f$export$de3fdf6493c353d","rows","size","getKeys","keyMap","keys","getKeyBefore","node","get","prevKey","getKeyAfter","nextKey","getFirstKey","getLastKey","at","idx","opts","Map","columnCount","visit","prevNode","visitNode","set","childKeys","last","parentKey","add","has","remove","delete","last1","items","forEach","i","rowNode","level","value","undefined","hasChildNodes","rendered","textValue","index","push"],"sources":["/home/kaytee/Desktop/crux/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/useGridState.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/GridCollection.ts"],"sourcesContent":["import {GridCollection} from '@react-types/grid';\nimport {Key, useEffect, useMemo} from 'react';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean\n}\n\nexport interface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell'\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = [...item.childNodes];\n        if (child === 'last') {\n          key = children[children.length - 1]?.key;\n        } else {\n          key = children[0]?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [collection, selectionState]);\n\n  return {\n    collection,\n    disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: new SelectionManager(collection, selectionState)\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from 'react';\n\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts?: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T>;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T>;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      } as GridNode<T>;\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    });\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}