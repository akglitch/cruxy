{"ast":null,"code":"import { Section as $6555104ff085bef4$re_export$Section, useCollection as $1BfjW$useCollection } from \"@react-stately/collections\";\nimport $1BfjW$react, { useRef as $1BfjW$useRef, useState as $1BfjW$useState, useCallback as $1BfjW$useCallback, useMemo as $1BfjW$useMemo } from \"react\";\nimport { useGridState as $1BfjW$useGridState, GridCollection as $1BfjW$GridCollection } from \"@react-stately/grid\";\nfunction $30561577df230a30$export$f61abf052f87399f(widths) {\n  return Array.from(widths).map(e => e[1]).reduce((acc, cur) => acc + cur, 0);\n}\nfunction $30561577df230a30$export$1994a077b98ee0d5(width) {\n  return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $30561577df230a30$var$parseFractionalUnit(width) {\n  if (!width) return 1;\n  let match = width.match(/^(\\d+)(?=fr$)/);\n  // if width is the incorrect format, just deafult it to a 1fr\n  if (!match) {\n    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, 'defaulting to \\'1fr\\'');\n    return 1;\n  }\n  return parseInt(match[0], 10);\n}\nfunction $30561577df230a30$export$7bbad27896f7ae9f(width, tableWidth) {\n  if (typeof width === 'string') {\n    let match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) throw new Error('Only percentages or numbers are supported for static column widths');\n    return tableWidth * (parseInt(match[0], 10) / 100);\n  }\n  return width;\n}\nfunction $30561577df230a30$export$59185c62a7544aa0(maxWidth, tableWidth) {\n  return maxWidth != null ? $30561577df230a30$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Infinity;\n}\nfunction $30561577df230a30$export$f556054ce4358701(minWidth, tableWidth) {\n  return minWidth != null ? $30561577df230a30$export$7bbad27896f7ae9f(minWidth, tableWidth) : 75;\n}\nfunction $30561577df230a30$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth) {\n  let fractions = dynamicColumns.reduce((sum, column) => sum + $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth), 0);\n  let columns = dynamicColumns.map((column, index) => {\n    const targetWidth = $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;\n    const delta = Math.max($30561577df230a30$export$f556054ce4358701(column.props.minWidth, tableWidth) - targetWidth, targetWidth - $30561577df230a30$export$59185c62a7544aa0(column.props.maxWidth, tableWidth));\n    return {\n      ...column,\n      index: index,\n      delta: delta\n    };\n  });\n  return columns;\n}\nfunction $30561577df230a30$var$findDynamicColumnWidths(dynamicColumns, availableSpace, tableWidth) {\n  let fractions = dynamicColumns.reduce((sum, col) => sum + $30561577df230a30$var$parseFractionalUnit(col.props.defaultWidth), 0);\n  const columns = dynamicColumns.map(column => {\n    const targetWidth = $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;\n    let width = Math.max($30561577df230a30$export$f556054ce4358701(column.props.minWidth, tableWidth), Math.min(Math.floor(targetWidth), $30561577df230a30$export$59185c62a7544aa0(column.props.maxWidth, tableWidth)));\n    column.calculatedWidth = width;\n    availableSpace -= width;\n    fractions -= $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth);\n    return column;\n  });\n  return columns;\n}\nfunction $30561577df230a30$export$a870e6692ac5ccb2(dynamicColumns, availableSpace, tableWidth) {\n  let columns = $30561577df230a30$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);\n  columns.sort((a, b) => b.delta - a.delta);\n  columns = $30561577df230a30$var$findDynamicColumnWidths(columns, availableSpace, tableWidth);\n  columns.sort((a, b) => a.index - b.index);\n  return columns;\n}\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n  const {\n    getDefaultWidth: getDefaultWidth,\n    tableWidth: defaultTableWidth = null\n  } = props;\n  const {\n    columns: columns1\n  } = state;\n  const columnsRef = $1BfjW$useRef([]);\n  const tableWidth = $1BfjW$useRef(defaultTableWidth);\n  const isResizing = $1BfjW$useRef(null);\n  const startResizeContentWidth = $1BfjW$useRef();\n  const [columnWidths, setColumnWidths] = $1BfjW$useState(new Map(columns1.map(col => [col.key, 0])));\n  const columnWidthsRef = $1BfjW$useRef(columnWidths);\n  const affectedColumnWidthsRef = $1BfjW$useRef([]);\n  const [resizedColumns, setResizedColumns] = $1BfjW$useState(new Set());\n  const resizedColumnsRef = $1BfjW$useRef(resizedColumns);\n  const [currentlyResizingColumn, setCurrentlyResizingColumn] = $1BfjW$useState(null);\n  function setColumnWidthsForRef(newWidths) {\n    columnWidthsRef.current = newWidths;\n    // new map so that change detection is triggered\n    setColumnWidths(newWidths);\n  }\n  /*\n  returns the resolved column width in this order:\n  previously calculated width -> controlled width prop -> uncontrolled defaultWidth prop -> dev assigned width -> default dynamic width\n  */\n  let getResolvedColumnWidth = $1BfjW$useCallback(column => {\n    let columnProps = column.props;\n    var _width, ref, ref1;\n    return (resizedColumns === null || resizedColumns === void 0 ? void 0 : resizedColumns.has(column.key)) ? columnWidthsRef.current.get(column.key) : (ref1 = (ref = (_width = columnProps.width) !== null && _width !== void 0 ? _width : columnProps.defaultWidth) !== null && ref !== void 0 ? ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(column.props)) !== null && ref1 !== void 0 ? ref1 : '1fr';\n  }, [getDefaultWidth, resizedColumns]);\n  let getStaticAndDynamicColumns = $1BfjW$useCallback(columns => columns.reduce((acc, column) => {\n    let width = getResolvedColumnWidth(column);\n    return $30561577df230a30$export$1994a077b98ee0d5(width) ? {\n      ...acc,\n      staticColumns: [...acc.staticColumns, column]\n    } : {\n      ...acc,\n      dynamicColumns: [...acc.dynamicColumns, column]\n    };\n  }, {\n    staticColumns: [],\n    dynamicColumns: []\n  }), [getResolvedColumnWidth]);\n  let buildColumnWidths = $1BfjW$useCallback((affectedColumns, availableSpace) => {\n    const widths = new Map();\n    let remainingSpace = availableSpace;\n    const {\n      staticColumns: staticColumns,\n      dynamicColumns: dynamicColumns\n    } = getStaticAndDynamicColumns(affectedColumns);\n    staticColumns.forEach(column => {\n      let width = getResolvedColumnWidth(column);\n      let w = $30561577df230a30$export$7bbad27896f7ae9f(width, tableWidth.current);\n      widths.set(column.key, w);\n      remainingSpace -= w;\n    });\n    // dynamic columns\n    if (dynamicColumns.length > 0) {\n      const newColumnWidths = $30561577df230a30$export$a870e6692ac5ccb2(dynamicColumns, remainingSpace, tableWidth.current);\n      for (let column of newColumnWidths) widths.set(column.key, column.calculatedWidth);\n    }\n    return widths;\n  }, [getStaticAndDynamicColumns, getResolvedColumnWidth]);\n  const prevColKeys = columnsRef.current.map(col => col.key);\n  const colKeys = columns1.map(col => col.key);\n  // if the columns change, need to rebuild widths.\n  if (prevColKeys.length !== colKeys.length || !colKeys.every((col, i) => col === prevColKeys[i])) {\n    columnsRef.current = columns1;\n    const widths = buildColumnWidths(columns1, tableWidth.current);\n    setColumnWidthsForRef(widths);\n  }\n  function setTableWidth(width) {\n    if (width && width !== tableWidth.current) {\n      tableWidth.current = width;\n      if (!isResizing.current) {\n        const widths = buildColumnWidths(columns1, width);\n        setColumnWidthsForRef(widths);\n      }\n    }\n  }\n  function onColumnResizeStart(column) {\n    setCurrentlyResizingColumn(column.key);\n    isResizing.current = true;\n    startResizeContentWidth.current = $30561577df230a30$export$f61abf052f87399f(columnWidthsRef.current);\n  }\n  function onColumnResize(column, width) {\n    let widthsObj = resizeColumn(column, width);\n    affectedColumnWidthsRef.current = widthsObj;\n    props.onColumnResize && props.onColumnResize(affectedColumnWidthsRef.current);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function onColumnResizeEnd(column) {\n    setCurrentlyResizingColumn(null);\n    isResizing.current = false;\n    props.onColumnResizeEnd && props.onColumnResizeEnd(affectedColumnWidthsRef.current);\n    affectedColumnWidthsRef.current = [];\n    let widths = new Map(columnWidthsRef.current);\n    setColumnWidthsForRef(widths);\n  }\n  function resizeColumn(column1, newWidth) {\n    let boundedWidth = Math.max($30561577df230a30$export$f556054ce4358701(column1.props.minWidth, tableWidth.current), Math.min(Math.floor(newWidth), $30561577df230a30$export$59185c62a7544aa0(column1.props.maxWidth, tableWidth.current)));\n    // copy the columnWidths map and set the new width for the column being resized\n    let widths = new Map(columnWidthsRef.current);\n    widths.set(column1.key, boundedWidth);\n    // keep track of all columns that have been sized\n    resizedColumnsRef.current.add(column1.key);\n    setResizedColumns(resizedColumnsRef.current);\n    // get the columns affected by resize and remaining space\n    const resizeIndex = columnsRef.current.findIndex(col => col.key === column1.key);\n    let affectedColumns = columnsRef.current.slice(resizeIndex + 1);\n    // we only care about the columns that CAN be resized, we ignore static columns.\n    let {\n      dynamicColumns: dynamicColumns\n    } = getStaticAndDynamicColumns(affectedColumns);\n    // available space for affected columns\n    let availableSpace = columnsRef.current.reduce((acc, column, index) => {\n      if (index <= resizeIndex || $30561577df230a30$export$1994a077b98ee0d5(getResolvedColumnWidth(column))) return acc - widths.get(column.key);\n      return acc;\n    }, tableWidth.current);\n    // merge the unaffected column widths and the recalculated column widths\n    let recalculatedColumnWidths = buildColumnWidths(dynamicColumns, availableSpace);\n    widths = new Map([...widths, ...recalculatedColumnWidths]);\n    setColumnWidthsForRef(widths);\n    /*\n    when getting recalculated columns above, the column being resized is not considered \"recalculated\"\n    so we need to add it to the list of affected columns\n    */\n    let allAffectedColumns = [[column1.key, boundedWidth], ...recalculatedColumnWidths].map(_ref => {\n      let [key, width] = _ref;\n      return {\n        key: key,\n        width: width\n      };\n    });\n    return allAffectedColumns;\n  }\n  var ref2;\n  // This function is regenerated whenever columnWidthsRef.current changes in order to get the new correct ref value.\n  let getColumnWidth = $1BfjW$useCallback(key => (ref2 = columnWidthsRef.current.get(key)) !== null && ref2 !== void 0 ? ref2 : 0, [columnWidthsRef.current]);\n  let getColumnMinWidth = $1BfjW$useCallback(key => {\n    const columnIndex = columns1.findIndex(col => col.key === key);\n    if (columnIndex === -1) return;\n    return $30561577df230a30$export$f556054ce4358701(columns1[columnIndex].props.minWidth, tableWidth.current);\n  }, [columns1]);\n  let getColumnMaxWidth = $1BfjW$useCallback(key => {\n    const columnIndex = columns1.findIndex(col => col.key === key);\n    if (columnIndex === -1) return;\n    return $30561577df230a30$export$59185c62a7544aa0(columns1[columnIndex].props.maxWidth, tableWidth.current);\n  }, [columns1]);\n  return {\n    columnWidths: columnWidthsRef,\n    setTableWidth: setTableWidth,\n    onColumnResize: onColumnResize,\n    onColumnResizeStart: onColumnResizeStart,\n    onColumnResizeEnd: onColumnResizeEnd,\n    getColumnWidth: getColumnWidth,\n    getColumnMinWidth: getColumnMinWidth,\n    getColumnMaxWidth: getColumnMaxWidth,\n    currentlyResizingColumn: currentlyResizingColumn\n  };\n}\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$var$buildHeaderRows(keyMap, columnNodes) {\n  let columns = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n    while (parentKey) {\n      let parent = keyMap.get(parentKey);\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n        let {\n          column: column,\n          index: index\n        } = seen.get(parent);\n        if (index > col.length) break;\n        for (let i = index; i < col.length; i++) column.splice(i, 0, null);\n        // Adjust shifted indices\n        for (let i1 = col.length; i1 < column.length; i1++) if (column[i1] && seen.has(column[i1])) seen.get(column[i1]).index = i1;\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {\n          column: col,\n          index: col.length - 1\n        });\n      }\n      parentKey = parent.parentKey;\n    }\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column1 of columns) {\n    let i = maxLength - 1;\n    for (let item of column1) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n          row.push(placeholder);\n        }\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n        item.level = i;\n        item.index = colIndex;\n        row.push(item);\n      }\n      i--;\n    }\n    colIndex++;\n  }\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row1 of headerRows) {\n    let rowLength = row1.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder = {\n        type: 'placeholder',\n        key: 'placeholder-' + row1[row1.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row1[row1.length - 1].key\n      };\n      row1.push(placeholder);\n    }\n    i++;\n  }\n  return headerRows.map((childNodes, index) => {\n    let row = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index: index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes: childNodes,\n      textValue: null\n    };\n    return row;\n  });\n}\nvar tmp = Symbol.iterator;\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends $1BfjW$GridCollection {\n  *[tmp]() {\n    yield* this.body.childNodes;\n  }\n  get size() {\n    return [...this.body.childNodes].length;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    var ref;\n    return (ref = [...this.body.childNodes][0]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n  getLastKey() {\n    var ref;\n    let rows = [...this.body.childNodes];\n    return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  constructor(nodes, prev, opts) {\n    let rowHeaderColumnKeys = new Set();\n    let body;\n    let columns = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n      let rowHeaderColumn = {\n        type: 'column',\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = node => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n            if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return;\n        // do not go into childNodes\n      }\n\n      for (let child of node.childNodes) visit(child);\n    };\n    for (let node1 of nodes) visit(node1);\n    let headerRows = $788781baa30117fa$var$buildHeaderRows(columnKeyMap, columns);\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns[(opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) ? 1 : 0].key);\n  }\n}\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending',\n  descending: 'ascending'\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = $1BfjW$useState(false);\n  let {\n    selectionMode = 'none'\n  } = props;\n  let context = $1BfjW$useMemo(() => ({\n    showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',\n    selectionMode: selectionMode,\n    columns: []\n  }), [props.children, props.showSelectionCheckboxes, selectionMode]);\n  let collection = $1BfjW$useCollection(props, (nodes, prev) => new $788781baa30117fa$export$596e1b2e2cf93690(nodes, prev, context), context);\n  let {\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager\n  } = $1BfjW$useGridState({\n    ...props,\n    collection: collection\n  });\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled: isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n    sort(columnKey, direction) {\n      var ref;\n      props.onSortChange({\n        column: columnKey,\n        direction: direction !== null && direction !== void 0 ? direction : ((ref = props.sortDescriptor) === null || ref === void 0 ? void 0 : ref.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : 'ascending'\n      });\n    }\n  };\n}\nfunction $312ae3b56a94a86e$var$TableHeader(props) {\n  return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children,\n    columns: columns\n  } = props;\n  if (typeof children === 'function') {\n    if (!columns) throw new Error('props.children was a function but props.columns is missing');\n    for (let column of columns) yield {\n      type: 'column',\n      value: column,\n      renderer: children\n    };\n  } else {\n    let columns = [];\n    $1BfjW$react.Children.forEach(children, column => {\n      columns.push({\n        type: 'column',\n        element: column\n      });\n    });\n    yield* columns;\n  }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\nfunction $4ae5314bf50db1a3$var$TableBody(props) {\n  return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children,\n    items: items1\n  } = props;\n  yield {\n    type: 'body',\n    hasChildNodes: true,\n    props: props,\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items1) throw new Error('props.children was a function but props.items is missing');\n        for (let item of items1) yield {\n          type: 'item',\n          value: item,\n          renderer: children\n        };\n      } else {\n        let items = [];\n        $1BfjW$react.Children.forEach(children, item => {\n          items.push({\n            type: 'item',\n            element: item\n          });\n        });\n        yield* items;\n      }\n    }\n  };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\nfunction $1cd244557c2f97d5$var$Column(props) {\n  return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context1) {\n  let {\n    title: title,\n    children: children,\n    childColumns: childColumns1\n  } = props;\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n  let fullNodes = yield {\n    type: 'column',\n    hasChildNodes: !!childColumns1 || title && $1BfjW$react.Children.count(children) > 0,\n    rendered: rendered,\n    textValue: textValue,\n    props: props,\n    *childNodes() {\n      if (childColumns1) for (let child1 of childColumns1) yield {\n        type: 'column',\n        value: child1\n      };else if (title) {\n        let childColumns = [];\n        $1BfjW$react.Children.forEach(children, child => {\n          childColumns.push({\n            type: 'column',\n            element: child\n          });\n        });\n        yield* childColumns;\n      }\n    },\n    shouldInvalidate(newContext) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n  };\n  let updateContext = context => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) if (!node.hasChildNodes) context.columns.push(node);\n  };\n  updateContext(context1);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\nfunction $70d70eb16ea48428$var$Row(props) {\n  return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n  let {\n    children: children,\n    textValue: textValue\n  } = props;\n  yield {\n    type: 'item',\n    props: props,\n    textValue: textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: true,\n    *childNodes() {\n      // Process cells first\n      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') yield {\n        type: 'cell',\n        key: 'header',\n        props: {\n          isSelectionCell: true\n        }\n      };\n      if (typeof children === 'function') for (let column of context.columns) yield {\n        type: 'cell',\n        element: children(column.key),\n        key: column.key // this is combined with the row key by CollectionBuilder\n      };else {\n        let cells = [];\n        $1BfjW$react.Children.forEach(children, cell => {\n          cells.push({\n            type: 'cell',\n            element: cell\n          });\n        });\n        if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        yield* cells;\n      }\n    },\n    shouldInvalidate(newContext) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i) => c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.selectionMode !== context.selectionMode;\n    }\n  };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\nfunction $941d1d9a6a28982a$var$Cell(props) {\n  return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children: children\n  } = props;\n  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n  yield {\n    type: 'cell',\n    props: props,\n    rendered: children,\n    textValue: textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: false\n  };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\nexport { $292bc4e09cd0eb62$export$cb895dcf85db1319 as useTableColumnResizeState, $4a0dd036d492cee4$export$907bcc6c48325fd6 as useTableState, $312ae3b56a94a86e$export$f850895b287ef28e as TableHeader, $4ae5314bf50db1a3$export$76ccd210b9029917 as TableBody, $1cd244557c2f97d5$export$816b5d811295e6bc as Column, $70d70eb16ea48428$export$b59bdbef9ce70de2 as Row, $941d1d9a6a28982a$export$f6f0c3fe4ec306ea as Cell, $6555104ff085bef4$re_export$Section as Section };","map":{"version":3,"mappings":"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","names":["$30561577df230a30$export$f61abf052f87399f","widths","Array","from","map","e","reduce","acc","cur","$30561577df230a30$export$1994a077b98ee0d5","width","isNaN","String","match","$30561577df230a30$var$parseFractionalUnit","console","warn","parseInt","$30561577df230a30$export$7bbad27896f7ae9f","tableWidth","Error","$30561577df230a30$export$59185c62a7544aa0","maxWidth","Infinity","$30561577df230a30$export$f556054ce4358701","minWidth","$30561577df230a30$var$mapDynamicColumns","dynamicColumns","availableSpace","fractions","sum","column","props","defaultWidth","columns","index","targetWidth","delta","Math","max","$30561577df230a30$var$findDynamicColumnWidths","col","min","floor","calculatedWidth","$30561577df230a30$export$a870e6692ac5ccb2","sort","a","b","$292bc4e09cd0eb62$export$cb895dcf85db1319","state","getDefaultWidth","defaultTableWidth","columnsRef","$1BfjW$useRef","isResizing","startResizeContentWidth","columnWidths","setColumnWidths","$1BfjW$useState","Map","columns1","key","columnWidthsRef","affectedColumnWidthsRef","resizedColumns","setResizedColumns","Set","resizedColumnsRef","currentlyResizingColumn","setCurrentlyResizingColumn","setColumnWidthsForRef","newWidths","current","getResolvedColumnWidth","$1BfjW$useCallback","columnProps","_width","ref","ref1","has","get","getStaticAndDynamicColumns","staticColumns","buildColumnWidths","affectedColumns","remainingSpace","forEach","w","set","length","newColumnWidths","prevColKeys","colKeys","every","i","setTableWidth","onColumnResizeStart","onColumnResize","widthsObj","resizeColumn","onColumnResizeEnd","column1","newWidth","boundedWidth","add","resizeIndex","findIndex","slice","recalculatedColumnWidths","allAffectedColumns","ref2","getColumnWidth","getColumnMinWidth","columnIndex","getColumnMaxWidth","$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY","random","toString","$788781baa30117fa$var$buildHeaderRows","keyMap","columnNodes","seen","parentKey","parent","colspan","splice","i1","push","maxLength","c","headerRows","fill","colIndex","item","row","rowLength","p","placeholder","type","value","rendered","level","hasChildNodes","childNodes","textValue","nextKey","prevKey","row1","Symbol","iterator","$788781baa30117fa$export$596e1b2e2cf93690","$1BfjW$GridCollection","body","size","getKeys","keys","getKeyBefore","node","getKeyAfter","getFirstKey","getLastKey","rows","getItem","at","idx","nodes","prev","opts","rowHeaderColumnKeys","showSelectionCheckboxes","rowHeaderColumn","isSelectionCell","unshift","columnKeyMap","visit","isRowHeader","child","node1","columnCount","items","visitNode","$4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION","ascending","descending","$4a0dd036d492cee4$export$907bcc6c48325fd6","isKeyboardNavigationDisabled","setKeyboardNavigationDisabled","selectionMode","context","$1BfjW$useMemo","children","collection","$1BfjW$useCollection","disabledKeys","selectionManager","$1BfjW$useGridState","sortDescriptor","columnKey","direction","onSortChange","$312ae3b56a94a86e$var$TableHeader","getCollectionNode","renderer","$1BfjW$react","Children","element","$312ae3b56a94a86e$export$f850895b287ef28e","$4ae5314bf50db1a3$var$TableBody","items1","$4ae5314bf50db1a3$export$76ccd210b9029917","$1cd244557c2f97d5$var$Column","context1","title","childColumns","childColumns1","fullNodes","count","child1","shouldInvalidate","newContext","updateContext","$1cd244557c2f97d5$export$816b5d811295e6bc","$70d70eb16ea48428$var$Row","cells","cell","some","$70d70eb16ea48428$export$b59bdbef9ce70de2","$941d1d9a6a28982a$var$Cell","$941d1d9a6a28982a$export$f6f0c3fe4ec306ea"],"sources":["/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/utils.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/useTableColumnResizeState.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/TableCollection.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/useTableState.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/TableHeader.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/TableBody.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/Column.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/Row.ts","/home/kaytee/Desktop/crux/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/Cell.ts"],"sourcesContent":["import {GridNode} from '@react-types/grid';\nimport {Key} from 'react';\n\ntype mappedColumn<T> = GridNode<T> & {\n    index: number,\n    delta: number,\n    calculatedWidth?: number\n};\n\nexport function getContentWidth(widths: Map<Key, number>): number {\n  return Array.from(widths).map(e => e[1]).reduce((acc, cur) => acc + cur, 0);\n}\n\n// numbers and percents are considered static. *fr units or a lack of units are considered dynamic.\nexport function isStatic(width: number | string): boolean {\n  return width != null && (!isNaN(width as number) || (String(width)).match(/^(\\d+)(?=%$)/) !== null);\n} \n\nfunction parseFractionalUnit(width: string): number {\n  if (!width) {\n    return 1;\n  } \n  let match = width.match(/^(\\d+)(?=fr$)/);\n      // if width is the incorrect format, just deafult it to a 1fr\n  if (!match) {\n    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \n        'defaulting to \\'1fr\\'');\n    return 1;\n  }\n  return parseInt(match[0], 10);\n}\n\nexport function parseStaticWidth(width: number | string, tableWidth: number): number {\n  if (typeof width === 'string') {\n    let match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) {\n      throw new Error('Only percentages or numbers are supported for static column widths');\n    }\n    return tableWidth * (parseInt(match[0], 10) / 100);\n  }\n  return width;\n}\n    \n    \nexport function getMaxWidth(maxWidth: number | string, tableWidth: number): number {\n  return maxWidth != null\n        ? parseStaticWidth(maxWidth, tableWidth)\n        : Infinity;\n}\n\nexport function getMinWidth(minWidth: number | string, tableWidth: number): number {\n  return minWidth != null\n      ? parseStaticWidth(minWidth, tableWidth)\n      : 75;\n}\n\nfunction mapDynamicColumns<T>(dynamicColumns: GridNode<T>[], availableSpace: number, tableWidth: number): mappedColumn<T>[] {\n  let fractions = dynamicColumns.reduce(\n        (sum, column) => sum + parseFractionalUnit(column.props.defaultWidth),\n        0\n      );\n    \n  let columns = dynamicColumns.map((column, index) => {\n    const targetWidth =\n          (parseFractionalUnit(column.props.defaultWidth) * availableSpace) / fractions;\n    const delta = Math.max(\n      getMinWidth(column.props.minWidth, tableWidth) - targetWidth,\n      targetWidth - getMaxWidth(column.props.maxWidth, tableWidth)\n    );\n\n    return {\n      ...column,\n      index,\n      delta \n    };\n  });\n    \n  return columns;\n}\n\nfunction findDynamicColumnWidths<T>(dynamicColumns: mappedColumn<T>[], availableSpace: number, tableWidth: number): mappedColumn<T>[] {\n  let fractions = dynamicColumns.reduce(\n    (sum, col) => sum + parseFractionalUnit(col.props.defaultWidth),\n    0\n  );\n\n  const columns = dynamicColumns.map((column) => {\n    const targetWidth =\n      (parseFractionalUnit(column.props.defaultWidth) * availableSpace) / fractions;\n    let width = Math.max(\n      getMinWidth(column.props.minWidth, tableWidth),\n      Math.min(Math.floor(targetWidth), getMaxWidth(column.props.maxWidth, tableWidth))\n    );\n    column.calculatedWidth = width;\n    availableSpace -= width;\n    fractions -= parseFractionalUnit(column.props.defaultWidth);\n    return column;\n  });\n\n  return columns;\n}  \n    \nexport function getDynamicColumnWidths<T>(dynamicColumns: GridNode<T>[], availableSpace: number, tableWidth: number) {\n  let columns = mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);\n    \n  columns.sort((a, b) => b.delta - a.delta);\n  columns = findDynamicColumnWidths(columns, availableSpace, tableWidth);\n  columns.sort((a, b) => a.index - b.index);\n    \n  return columns;\n}\n","\nimport {ColumnProps} from '@react-types/table';\nimport {getContentWidth, getDynamicColumnWidths, getMaxWidth, getMinWidth, isStatic, parseStaticWidth} from './utils';\nimport {GridNode} from '@react-types/grid';\nimport {Key, MutableRefObject, useCallback, useRef, useState} from 'react';\n\ninterface AffectedColumnWidth {\n  /** The column key. */\n  key: Key,\n  /** The column width. */\n  width: number\n}\ninterface AffectedColumnWidths extends Array<AffectedColumnWidth> {}\n\nexport interface TableColumnResizeState<T> {\n  /** A ref whose current value is the state of all the column widths. */\n  columnWidths: MutableRefObject<Map<Key, number>>,\n  /** Setter for the table width. */\n  setTableWidth: (width: number) => void,\n  /** Trigger a resize and recalculation. */\n  onColumnResize: (column: GridNode<T>, width: number) => void,\n  /** Callback for when onColumnResize has started. */\n  onColumnResizeStart: (column: GridNode<T>) => void,\n  /** Callback for when onColumnResize has ended. */\n  onColumnResizeEnd: (column: GridNode<T>) => void,\n  /** Getter for column width. */\n  getColumnWidth: (key: Key) => number,\n  /** Getter for column min width. */\n  getColumnMinWidth: (key: Key) => number,\n  /** Getter for column max widths. */\n  getColumnMaxWidth: (key: Key) => number,\n  /** Key of column currently being resized. */\n  currentlyResizingColumn: Key | null\n}\n\nexport interface TableColumnResizeStateProps {\n  /** Callback to determine what the default width of a column should be. */\n  getDefaultWidth?: (props) => string | number,\n  /** Callback that is invoked during the entirety of the resize event. */\n  onColumnResize?: (affectedColumnWidths: AffectedColumnWidths) => void,\n  /** Callback that is invoked when the resize event is ended. */\n  onColumnResizeEnd?: (affectedColumnWidths: AffectedColumnWidths) => void,\n  /** The default table width. */\n  tableWidth?: number\n}\n\ninterface ColumnState<T> {\n  columns: GridNode<T>[]\n}\n\nexport function useTableColumnResizeState<T>(props: TableColumnResizeStateProps, state: ColumnState<T>): TableColumnResizeState<T> {\n  const {getDefaultWidth, tableWidth: defaultTableWidth = null} = props;\n  const {columns} = state;\n  const columnsRef = useRef<GridNode<T>[]>([]);\n  const tableWidth = useRef<number>(defaultTableWidth);\n  const isResizing = useRef<boolean>(null);\n  const startResizeContentWidth = useRef<number>();\n\n  const [columnWidths, setColumnWidths] = useState<Map<Key, number>>(new Map(columns.map(col => [col.key, 0])));\n  const columnWidthsRef = useRef<Map<Key, number>>(columnWidths);\n  const affectedColumnWidthsRef = useRef<AffectedColumnWidths>([]);\n  const [resizedColumns, setResizedColumns] = useState<Set<Key>>(new Set());\n  const resizedColumnsRef = useRef<Set<Key>>(resizedColumns);\n\n  const [currentlyResizingColumn, setCurrentlyResizingColumn] = useState<Key>(null);\n\n  function setColumnWidthsForRef(newWidths: Map<Key, number>) {\n    columnWidthsRef.current = newWidths;\n    // new map so that change detection is triggered\n    setColumnWidths(newWidths);\n  }\n  /*\n    returns the resolved column width in this order:\n    previously calculated width -> controlled width prop -> uncontrolled defaultWidth prop -> dev assigned width -> default dynamic width\n  */\n  let getResolvedColumnWidth = useCallback((column: GridNode<T>): (number | string) => {\n    let columnProps = column.props as ColumnProps<T>;\n    return resizedColumns?.has(column.key) ? columnWidthsRef.current.get(column.key) : columnProps.width ?? columnProps.defaultWidth ?? getDefaultWidth?.(column.props) ?? '1fr';\n  }, [getDefaultWidth, resizedColumns]);\n\n  let getStaticAndDynamicColumns = useCallback((columns: GridNode<T>[]) : { staticColumns: GridNode<T>[], dynamicColumns: GridNode<T>[] } => columns.reduce((acc, column) => {\n    let width = getResolvedColumnWidth(column);\n    return isStatic(width) ? {...acc, staticColumns: [...acc.staticColumns, column]} : {...acc, dynamicColumns: [...acc.dynamicColumns, column]};\n  }, {staticColumns: [], dynamicColumns: []}), [getResolvedColumnWidth]);\n\n  let buildColumnWidths = useCallback((affectedColumns: GridNode<T>[], availableSpace: number): Map<Key, number> => {\n    const widths = new Map<Key, number>();\n    let remainingSpace = availableSpace;\n\n    const {staticColumns, dynamicColumns} = getStaticAndDynamicColumns(affectedColumns);\n\n    staticColumns.forEach(column => {\n      let width = getResolvedColumnWidth(column);\n      let w = parseStaticWidth(width, tableWidth.current);\n      widths.set(column.key, w);\n      remainingSpace -= w;\n    });\n\n    // dynamic columns\n    if (dynamicColumns.length > 0) {\n      const newColumnWidths = getDynamicColumnWidths(dynamicColumns, remainingSpace, tableWidth.current);\n      for (let column of newColumnWidths) {\n        widths.set(column.key, column.calculatedWidth);\n      }\n    }\n\n    return widths;\n  }, [getStaticAndDynamicColumns, getResolvedColumnWidth]);\n\n\n  const prevColKeys = columnsRef.current.map(col => col.key);\n  const colKeys = columns.map(col => col.key);\n  // if the columns change, need to rebuild widths.\n  if (prevColKeys.length !== colKeys.length || !colKeys.every((col, i) => col === prevColKeys[i])) {\n    columnsRef.current = columns;\n    const widths = buildColumnWidths(columns, tableWidth.current);\n    setColumnWidthsForRef(widths);\n  }\n\n  function setTableWidth(width: number) {\n    if (width && width !== tableWidth.current) {\n      tableWidth.current = width;\n      if (!isResizing.current) {\n        const widths = buildColumnWidths(columns, width);\n        setColumnWidthsForRef(widths);\n      }\n    }\n  }\n\n  function onColumnResizeStart(column: GridNode<T>) {\n    setCurrentlyResizingColumn(column.key);\n    isResizing.current = true;\n    startResizeContentWidth.current = getContentWidth(columnWidthsRef.current);\n  }\n\n  function onColumnResize(column: GridNode<T>, width: number) {\n    let widthsObj = resizeColumn(column, width);\n    affectedColumnWidthsRef.current = widthsObj;\n    props.onColumnResize && props.onColumnResize(affectedColumnWidthsRef.current);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function onColumnResizeEnd(column: GridNode<T>) {\n    setCurrentlyResizingColumn(null);\n    isResizing.current = false;\n    props.onColumnResizeEnd && props.onColumnResizeEnd(affectedColumnWidthsRef.current);\n    affectedColumnWidthsRef.current = [];\n\n    let widths = new Map<Key, number>(columnWidthsRef.current);\n    setColumnWidthsForRef(widths);\n  }\n\n  function resizeColumn(column: GridNode<T>, newWidth: number) : AffectedColumnWidths {\n    let boundedWidth =  Math.max(\n      getMinWidth(column.props.minWidth, tableWidth.current),\n      Math.min(Math.floor(newWidth), getMaxWidth(column.props.maxWidth, tableWidth.current)));\n\n    // copy the columnWidths map and set the new width for the column being resized\n    let widths = new Map<Key, number>(columnWidthsRef.current);\n    widths.set(column.key, boundedWidth);\n\n    // keep track of all columns that have been sized\n    resizedColumnsRef.current.add(column.key);\n    setResizedColumns(resizedColumnsRef.current);\n\n    // get the columns affected by resize and remaining space\n    const resizeIndex = columnsRef.current.findIndex(col => col.key === column.key);\n    let affectedColumns = columnsRef.current.slice(resizeIndex + 1);\n\n    // we only care about the columns that CAN be resized, we ignore static columns.\n    let {dynamicColumns} = getStaticAndDynamicColumns(affectedColumns);\n\n    // available space for affected columns\n    let availableSpace = columnsRef.current.reduce((acc, column, index) => {\n      if (index <= resizeIndex || isStatic(getResolvedColumnWidth(column))) {\n        return acc - widths.get(column.key);\n      }\n      return acc;\n    }, tableWidth.current);\n\n    // merge the unaffected column widths and the recalculated column widths\n    let recalculatedColumnWidths = buildColumnWidths(dynamicColumns, availableSpace);\n    widths = new Map<Key, number>([...widths, ...recalculatedColumnWidths]);\n\n    setColumnWidthsForRef(widths);\n\n    /*\n     when getting recalculated columns above, the column being resized is not considered \"recalculated\"\n     so we need to add it to the list of affected columns\n    */\n    let allAffectedColumns = ([[column.key, boundedWidth], ...recalculatedColumnWidths] as [Key, number][]).map(([key, width]) => ({key, width}));\n    return allAffectedColumns;\n  }\n\n  // This function is regenerated whenever columnWidthsRef.current changes in order to get the new correct ref value.\n  let getColumnWidth = useCallback((key: Key): number => columnWidthsRef.current.get(key) ?? 0, [columnWidthsRef.current]);\n\n  let getColumnMinWidth = useCallback((key: Key) => {\n    const columnIndex = columns.findIndex(col => col.key === key);\n    if (columnIndex === -1) {\n      return;\n    }\n    return getMinWidth(columns[columnIndex].props.minWidth, tableWidth.current);\n  }, [columns]);\n\n  let getColumnMaxWidth = useCallback((key: Key) => {\n    const columnIndex = columns.findIndex(col => col.key === key);\n    if (columnIndex === -1) {\n      return;\n    }\n    return getMaxWidth(columns[columnIndex].props.maxWidth, tableWidth.current);\n  }, [columns]);\n\n  return {\n    columnWidths: columnWidthsRef,\n    setTableWidth,\n    onColumnResize,\n    onColumnResizeStart,\n    onColumnResizeEnd,\n    getColumnWidth,\n    getColumnMinWidth,\n    getColumnMaxWidth,\n    currentlyResizingColumn\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridCollection} from '@react-stately/grid';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from 'react';\n\ninterface GridCollectionOptions {\n  showSelectionCheckboxes?: boolean\n}\n\nconst ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\n\nfunction buildHeaderRows<T>(keyMap: Map<Key, GridNode<T>>, columnNodes: GridNode<T>[]): GridNode<T>[] {\n  let columns = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n\n    while (parentKey) {\n      let parent: GridNode<T> = keyMap.get(parentKey);\n\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n\n        let {column, index} = seen.get(parent);\n        if (index > col.length) {\n          break;\n        }\n\n        for (let i = index; i < col.length; i++) {\n          column.splice(i, 0, null);\n        }\n\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++) {\n          if (column[i] && seen.has(column[i])) {\n            seen.get(column[i]).index = i;\n          }\n        }\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {column: col, index: col.length - 1});\n      }\n\n      parentKey = parent.parentKey;\n    }\n\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder: GridNode<T> = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n\n          row.push(placeholder);\n        }\n\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n\n        item.level = i;\n        item.index = colIndex;\n        row.push(item);\n      }\n\n      i--;\n    }\n\n    colIndex++;\n  }\n\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder: GridNode<T> = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row[row.length - 1].key\n      };\n\n      row.push(placeholder);\n    }\n\n    i++;\n  }\n\n  return headerRows.map((childNodes, index) => {\n    let row: GridNode<T> = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes,\n      textValue: null\n    };\n\n    return row;\n  });\n}\n\nexport class TableCollection<T> extends GridCollection<T> {\n  headerRows: GridNode<T>[];\n  columns: GridNode<T>[];\n  rowHeaderColumnKeys: Set<Key>;\n  body: GridNode<T>;\n\n  constructor(nodes: Iterable<GridNode<T>>, prev?: TableCollection<T>, opts?: GridCollectionOptions) {\n    let rowHeaderColumnKeys: Set<Key> = new Set();\n    let body: GridNode<T>;\n    let columns = [];\n\n    // Add cell for selection checkboxes if needed.\n    if (opts?.showSelectionCheckboxes) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = (node: GridNode<T>) => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n\n            if (node.props.isRowHeader) {\n              rowHeaderColumnKeys.add(node.key);\n            }\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return; // do not go into childNodes\n      }\n      for (let child of node.childNodes) {\n        visit(child);\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let headerRows = buildHeaderRows(columnKeyMap, columns) as GridNode<T>[];\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      this.rowHeaderColumnKeys.add(this.columns[opts?.showSelectionCheckboxes ? 1 : 0].key);\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n\n  get size() {\n    return [...this.body.childNodes].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.body.childNodes][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.body.childNodes];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBase, Node, SelectionMode, Sortable, SortDescriptor, SortDirection} from '@react-types/shared';\nimport {GridState, useGridState} from '@react-stately/grid';\nimport {TableCollection as ITableCollection} from '@react-types/table';\nimport {Key, useMemo, useState} from 'react';\nimport {MultipleSelectionStateProps} from '@react-stately/selection';\nimport {TableCollection} from './TableCollection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface TableState<T> extends GridState<T, ITableCollection<T>> {\n  /** A collection of rows and columns in the table. */\n  collection: ITableCollection<T>,\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes: boolean,\n  /** The current sorted column and direction. */\n  sortDescriptor: SortDescriptor,\n  /** Calls the provided onSortChange handler with the provided column key and sort direction. */\n  sort(columnKey: Key, direction?: 'ascending' | 'descending'): void,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean,\n  /** Set whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  setKeyboardNavigationDisabled: (val: boolean) => void\n}\n\nexport interface CollectionBuilderContext<T> {\n  showSelectionCheckboxes: boolean,\n  selectionMode: SelectionMode,\n  columns: Node<T>[]\n}\n\nexport interface TableStateProps<T> extends CollectionBase<T>, MultipleSelectionStateProps, Sortable {\n  /** Whether the row selection checkboxes should be displayed. */\n  showSelectionCheckboxes?: boolean\n}\n\nconst OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending' as SortDirection,\n  descending: 'ascending' as SortDirection\n};\n\n/**\n * Provides state management for a table component. Handles building a collection\n * of columns and rows from props. In addition, it tracks row selection and manages sort order changes.\n */\nexport function useTableState<T extends object>(props: TableStateProps<T>): TableState<T> {\n  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = useState(false);\n  let {selectionMode = 'none'} = props;\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',\n    selectionMode,\n    columns: []\n  }), [props.children, props.showSelectionCheckboxes, selectionMode]);\n\n  let collection = useCollection<T, TableCollection<T>>(\n    props,\n    (nodes, prev) => new TableCollection(nodes, prev, context),\n    context\n  );\n  let {disabledKeys, selectionManager} = useGridState({...props, collection});\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled,\n    sort(columnKey: Key, direction?: 'ascending' | 'descending') {\n      props.onSortChange({\n        column: columnKey,\n        direction: direction ?? (props.sortDescriptor?.column === columnKey\n          ? OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction]\n          : 'ascending')\n      });\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableHeaderProps} from '@react-types/table';\n\nfunction TableHeader<T>(props: TableHeaderProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableHeader.getCollectionNode = function* getCollectionNode<T>(props: TableHeaderProps<T>): Generator<PartialNode<T>, void, any> {\n  let {children, columns} = props;\n  if (typeof children === 'function') {\n    if (!columns) {\n      throw new Error('props.children was a function but props.columns is missing');\n    }\n\n    for (let column of columns) {\n      yield {\n        type: 'column',\n        value: column,\n        renderer: children\n      };\n    }\n  } else {\n    let columns: PartialNode<T>[] = [];\n    React.Children.forEach(children, column => {\n      columns.push({\n        type: 'column',\n        element: column\n      });\n    });\n\n    yield* columns;\n  }\n};\n\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableHeader = TableHeader as <T>(props: TableHeaderProps<T>) => JSX.Element;\nexport {_TableHeader as TableHeader};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {TableBodyProps} from '@react-types/table';\n\nfunction TableBody<T>(props: TableBodyProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nTableBody.getCollectionNode = function* getCollectionNode<T>(props: TableBodyProps<T>): Generator<PartialNode<T>> {\n  let {children, items} = props;\n  yield {\n    type: 'body',\n    hasChildNodes: true,\n    props,\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items) {\n          throw new Error('props.children was a function but props.items is missing');\n        }\n\n        for (let item of items) {\n          yield {\n            type: 'item',\n            value: item,\n            renderer: children\n          };\n        }\n      } else {\n        let items: PartialNode<T>[] = [];\n        React.Children.forEach(children, item => {\n          items.push({\n            type: 'item',\n            element: item\n          });\n        });\n\n        yield* items;\n      }\n    }\n  };\n};\n\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _TableBody = TableBody as <T>(props: TableBodyProps<T>) => JSX.Element;\nexport {_TableBody as TableBody};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {ColumnProps} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\n\nfunction Column<T>(props: ColumnProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nColumn.getCollectionNode = function* getCollectionNode<T>(props: ColumnProps<T>, context: CollectionBuilderContext<T>): Generator<PartialNode<T>, void, GridNode<T>[]> {\n  let {title, children, childColumns} = props;\n\n  let rendered = title || children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n\n  let fullNodes = yield {\n    type: 'column',\n    hasChildNodes: !!childColumns || (title && React.Children.count(children) > 0),\n    rendered,\n    textValue,\n    props,\n    *childNodes() {\n      if (childColumns) {\n        for (let child of childColumns) {\n          yield {\n            type: 'column',\n            value: child\n          };\n        }\n      } else if (title) {\n        let childColumns: PartialNode<T>[] = [];\n        React.Children.forEach(children, child => {\n          childColumns.push({\n            type: 'column',\n            element: child as ReactElement<ColumnProps<T>>\n          });\n        });\n\n        yield* childColumns;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // This is a bit of a hack, but it works.\n      // If this method is called, then there's a cached version of this node available.\n      // But, we need to keep the list of columns in the new context up to date.\n      updateContext(newContext);\n      return false;\n    }\n  };\n\n  let updateContext = (context: CollectionBuilderContext<T>) => {\n    // register leaf columns on the context so that <Row> can access them\n    for (let node of fullNodes) {\n      if (!node.hasChildNodes) {\n        context.columns.push(node);\n      }\n    }\n  };\n\n  updateContext(context);\n};\n\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Column = Column as <T>(props: ColumnProps<T>) => JSX.Element;\nexport {_Column as Column};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilderContext} from './useTableState';\nimport {PartialNode} from '@react-stately/collections';\nimport React, {ReactElement} from 'react';\nimport {RowProps} from '@react-types/table';\n\nfunction Row(props: RowProps): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nRow.getCollectionNode = function* getCollectionNode<T>(props: RowProps, context: CollectionBuilderContext<T>): Generator<PartialNode<T>> {\n  let {children, textValue} = props;\n\n  yield {\n    type: 'item',\n    props: props,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: true,\n    *childNodes() {\n      // Process cells first\n      if (context.showSelectionCheckboxes && context.selectionMode !== 'none') {\n        yield {\n          type: 'cell',\n          key: 'header', // this is combined with the row key by CollectionBuilder\n          props: {\n            isSelectionCell: true\n          }\n        };\n      }\n\n      if (typeof children === 'function') {\n        for (let column of context.columns) {\n          yield {\n            type: 'cell',\n            element: children(column.key),\n            key: column.key // this is combined with the row key by CollectionBuilder\n          };\n        }\n      } else {\n        let cells: PartialNode<T>[] = [];\n        React.Children.forEach(children, cell => {\n          cells.push({\n            type: 'cell',\n            element: cell\n          });\n        });\n\n        if (cells.length !== context.columns.length) {\n          throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n        }\n\n        yield* cells;\n      }\n    },\n    shouldInvalidate(newContext: CollectionBuilderContext<T>) {\n      // Invalidate all rows if the columns changed.\n      return newContext.columns.length !== context.columns.length ||\n        newContext.columns.some((c, i) => c.key !== context.columns[i].key) ||\n        newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes ||\n        newContext.selectionMode !== context.selectionMode;\n    }\n  };\n};\n\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Row = Row as (props: RowProps) => JSX.Element;\nexport {_Row as Row};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CellProps} from '@react-types/table';\nimport {PartialNode} from '@react-stately/collections';\nimport {ReactElement} from 'react';\n\nfunction Cell(props: CellProps): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nCell.getCollectionNode = function* getCollectionNode<T>(props: CellProps): Generator<PartialNode<T>> {\n  let {children} = props;\n\n  let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n  yield {\n    type: 'cell',\n    props: props,\n    rendered: children,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: false\n  };\n};\n\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */\n// We don't want getCollectionNode to show up in the type definition\nlet _Cell = Cell as (props: CellProps) => JSX.Element;\nexport {_Cell as Cell};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}