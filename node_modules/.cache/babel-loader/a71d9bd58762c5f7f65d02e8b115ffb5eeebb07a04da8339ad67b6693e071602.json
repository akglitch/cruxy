{"ast":null,"code":"class $5b160d28a433310d$export$c17fa47878dc55b6 {\n  /** Returns a localized string for the given key and locale. */getStringForLocale(key, locale) {\n    let strings = this.strings[locale];\n    if (!strings) {\n      strings = $5b160d28a433310d$var$getStringsForLocale(locale, this.strings, this.defaultLocale);\n      this.strings[locale] = strings;\n    }\n    let string = strings[key];\n    if (!string) throw new Error(`Could not find intl message ${key} in ${locale} locale`);\n    return string;\n  }\n  constructor(messages) {\n    let defaultLocale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n    // Clone messages so we don't modify the original object.\n    this.strings = {\n      ...messages\n    };\n    this.defaultLocale = defaultLocale;\n  }\n}\nfunction $5b160d28a433310d$var$getStringsForLocale(locale, strings) {\n  let defaultLocale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en-US';\n  // If there is an exact match, use it.\n  if (strings[locale]) return strings[locale];\n  // Attempt to find the closest match by language.\n  // For example, if the locale is fr-CA (French Canadian), but there is only\n  // an fr-FR (France) set of strings, use that.\n  // This could be replaced with Intl.LocaleMatcher once it is supported.\n  // https://github.com/tc39/proposal-intl-localematcher\n  let language = $5b160d28a433310d$var$getLanguage(locale);\n  if (strings[language]) return strings[language];\n  for (let key in strings) {\n    if (key.startsWith(language + '-')) return strings[key];\n  }\n  // Nothing close, use english.\n  return strings[defaultLocale];\n}\nfunction $5b160d28a433310d$var$getLanguage(locale) {\n  // @ts-ignore\n  if (Intl.Locale)\n    // @ts-ignore\n    return new Intl.Locale(locale).language;\n  return locale.split('-')[0];\n}\nconst $6db58dc88e78b024$var$pluralRulesCache = new Map();\nconst $6db58dc88e78b024$var$numberFormatCache = new Map();\nclass $6db58dc88e78b024$export$2f817fcdc4b89ae0 {\n  /** Formats a localized string for the given key with the provided variables. */format(key, variables) {\n    let message = this.strings.getStringForLocale(key, this.locale);\n    return typeof message === 'function' ? message(variables, this) : message;\n  }\n  plural(count, options) {\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'cardinal';\n    let opt = options['=' + count];\n    if (opt) return typeof opt === 'function' ? opt() : opt;\n    let key = this.locale + ':' + type;\n    let pluralRules = $6db58dc88e78b024$var$pluralRulesCache.get(key);\n    if (!pluralRules) {\n      pluralRules = new Intl.PluralRules(this.locale, {\n        type: type\n      });\n      $6db58dc88e78b024$var$pluralRulesCache.set(key, pluralRules);\n    }\n    let selected = pluralRules.select(count);\n    opt = options[selected] || options.other;\n    return typeof opt === 'function' ? opt() : opt;\n  }\n  number(value) {\n    let numberFormat = $6db58dc88e78b024$var$numberFormatCache.get(this.locale);\n    if (!numberFormat) {\n      numberFormat = new Intl.NumberFormat(this.locale);\n      $6db58dc88e78b024$var$numberFormatCache.set(this.locale, numberFormat);\n    }\n    return numberFormat.format(value);\n  }\n  select(options, value) {\n    let opt = options[value] || options.other;\n    return typeof opt === 'function' ? opt() : opt;\n  }\n  constructor(locale, strings) {\n    this.locale = locale;\n    this.strings = strings;\n  }\n}\nexport { $5b160d28a433310d$export$c17fa47878dc55b6 as LocalizedStringDictionary, $6db58dc88e78b024$export$2f817fcdc4b89ae0 as LocalizedStringFormatter };","map":{"version":3,"mappings":"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","names":["$5b160d28a433310d$export$c17fa47878dc55b6","getStringForLocale","key","locale","strings","$5b160d28a433310d$var$getStringsForLocale","defaultLocale","string","Error","messages","language","$5b160d28a433310d$var$getLanguage","startsWith","Intl","Locale","split","$6db58dc88e78b024$var$pluralRulesCache","Map","$6db58dc88e78b024$var$numberFormatCache","$6db58dc88e78b024$export$2f817fcdc4b89ae0","format","variables","message","plural","count","options","type","opt","pluralRules","get","PluralRules","set","selected","select","other","number","value","numberFormat","NumberFormat"],"sources":["/home/kaytee/Desktop/cruxy/node_modules/@internationalized/string/dist/packages/@internationalized/string/src/LocalizedStringDictionary.ts","/home/kaytee/Desktop/cruxy/node_modules/@internationalized/string/dist/packages/@internationalized/string/src/LocalizedStringFormatter.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {LocalizedString} from './LocalizedStringFormatter';\n\nexport type LocalizedStrings<K extends string, T extends LocalizedString> = {\n  [lang: string]: Record<K, T>\n};\n\n/**\n * Stores a mapping of localized strings. Can be used to find the\n * closest available string for a given locale.\n */\nexport class LocalizedStringDictionary<K extends string = string, T extends LocalizedString = string> {\n  private strings: LocalizedStrings<K, T>;\n  private defaultLocale: string;\n\n  constructor(messages: LocalizedStrings<K, T>, defaultLocale: string = 'en-US') {\n    // Clone messages so we don't modify the original object.\n    this.strings = {...messages};\n    this.defaultLocale = defaultLocale;\n  }\n\n  /** Returns a localized string for the given key and locale. */\n  getStringForLocale(key: K, locale: string): T {\n    let strings = this.strings[locale];\n    if (!strings) {\n      strings = getStringsForLocale(locale, this.strings, this.defaultLocale);\n      this.strings[locale] = strings;\n    }\n\n    let string = strings[key];\n    if (!string) {\n      throw new Error(`Could not find intl message ${key} in ${locale} locale`);\n    }\n\n    return string;\n  }\n}\n\nfunction getStringsForLocale<K extends string, T extends LocalizedString>(locale: string, strings: LocalizedStrings<K, T>, defaultLocale = 'en-US') {\n  // If there is an exact match, use it.\n  if (strings[locale]) {\n    return strings[locale];\n  }\n\n  // Attempt to find the closest match by language.\n  // For example, if the locale is fr-CA (French Canadian), but there is only\n  // an fr-FR (France) set of strings, use that.\n  // This could be replaced with Intl.LocaleMatcher once it is supported.\n  // https://github.com/tc39/proposal-intl-localematcher\n  let language = getLanguage(locale);\n  if (strings[language]) {\n    return strings[language];\n  }\n\n  for (let key in strings) {\n    if (key.startsWith(language + '-')) {\n      return strings[key];\n    }\n  }\n\n  // Nothing close, use english.\n  return strings[defaultLocale];\n}\n\nfunction getLanguage(locale: string) {\n  // @ts-ignore\n  if (Intl.Locale) {\n    // @ts-ignore\n    return new Intl.Locale(locale).language;\n  }\n\n  return locale.split('-')[0];\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {LocalizedStringDictionary} from './LocalizedStringDictionary';\n\nexport type Variables = Record<string, string | number | boolean> | undefined;\nexport type LocalizedString = string | ((args: Variables, formatter?: LocalizedStringFormatter<any, any>) => string);\ntype InternalString = string | (() => string);\n\nconst pluralRulesCache = new Map<string, Intl.PluralRules>();\nconst numberFormatCache = new Map<string, Intl.NumberFormat>();\n\n/**\n * Formats localized strings from a LocalizedStringDictionary. Supports interpolating variables,\n * selecting the correct pluralization, and formatting numbers for the locale.\n */\nexport class LocalizedStringFormatter<K extends string = string, T extends LocalizedString = string> {\n  private locale: string;\n  private strings: LocalizedStringDictionary<K, T>;\n\n  constructor(locale: string, strings: LocalizedStringDictionary<K, T>) {\n    this.locale = locale;\n    this.strings = strings;\n  }\n\n  /** Formats a localized string for the given key with the provided variables. */\n  format(key: K, variables?: Variables): string {\n    let message = this.strings.getStringForLocale(key, this.locale);\n    return typeof message === 'function' ? message(variables, this) : message;\n  }\n\n  protected plural(count: number, options: Record<string, InternalString>, type: Intl.PluralRuleType = 'cardinal') {\n    let opt = options['=' + count];\n    if (opt) {\n      return typeof opt === 'function' ? opt() : opt;\n    }\n\n    let key = this.locale + ':' + type;\n    let pluralRules = pluralRulesCache.get(key);\n    if (!pluralRules) {\n      pluralRules = new Intl.PluralRules(this.locale, {type});\n      pluralRulesCache.set(key, pluralRules);\n    }\n\n    let selected = pluralRules.select(count);\n    opt = options[selected] || options.other;\n    return typeof opt === 'function' ? opt() : opt;\n  }\n\n  protected number(value: number) {\n    let numberFormat = numberFormatCache.get(this.locale);\n    if (!numberFormat) {\n      numberFormat = new Intl.NumberFormat(this.locale);\n      numberFormatCache.set(this.locale, numberFormat);\n    }\n    return numberFormat.format(value);\n  }\n\n  protected select(options: Record<string, InternalString>, value: string) {\n    let opt = options[value] || options.other;\n    return typeof opt === 'function' ? opt() : opt;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}